# Cross-repository GitHub pull request status check pipeline
# Patrick Healy, patrick.healy@microsoft.com
#
# This pipeline is designed to be triggered using an Azure Pipelines
# Incoming Webhook Service Connection from a GitHub repository based
# on a pull-request webhook. It will only act on actions that indicate
# code was changed, and will run one or more checkout tasks on the pull
# request head branch. It will then use the Azure Pipelines PAT to
# post a commit status back to GitHub, which allows it to be used as a
# protected branch check for pull requests.
#
# NOTE: you must manually trigger this pipeline once to register the
# webhook before GitHub can trigger it.
#
# Azure Pipelines Incoming Webhooks:
# https://docs.microsoft.com/en-us/azure/devops/release-notes/2020/pipelines/sprint-172-update#generic-webhook-based-triggers-for-yaml-pipelines
#
# GitHub commit status post API:
# https://docs.github.com/en/rest/reference/repos#create-a-commit-status
#
# GitHub pull request webhook event:
# https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads#pull_request

trigger:
  - none

# These are what show in the pull request status check line. The context
# needs to be unique for the repository as it's the identifier used to set
# the required status check.
parameters:
  # - name: checkContext
  #   type: string
  # - name: checkDescription
  #   type: string
  - name: githubpr
    type: object
  - name: checkoutSteps
    type: stepList
    default: []

# Note the condition on this job - it will skip the whole thing unless the
# action is in this list. Because the webhook is triggered for every PR change
# and I don't know how to filter to a list of values in the webhook connection,
# this prevents an agent allocation and finishes the pipeline run successfully
# in <1s when it's just something like a comment on the PR.
jobs:
  - job: performCheckout
    displayName: Perform checkout
    #condition: in('${{ parameters.githubpr.action }}', 'opened', 'reopened', 'edited', 'synchronize')
    steps:
      - checkout: githubrepo
        displayName: Check out base repository
        persistCredentials: true
        # persistCredentials allows us to use the PAT generated by AzDO to post
        # to the status API below.

      # Set up some initial variables
      - script: |
          # Create a temporary directory to put our status files in
          echo "##vso[task.setvariable variable=statusPostOutputDirectory]$(mktemp -d)"
          export

          # Fetch the PAT from the git configuration.
          GIT_REMOTE="$(git config --get remote.origin.url)"
          echo "GIT_REMOTE is $GIT_REMOTE"
          echo "##vso[task.setvariable variable=gitAuthToken;isSecret=true]$(git config --get "http.${GIT_REMOTE}.extraheader")"

      # Post the initial pending status to GitHub and initialize the tokens for later
      - script: |
          echo "Status post to ${{ parameters.githubpr.pull_request.statuses_url }}:"
          cat << EOF | tee "${STATUSPOSTOUTPUTDIRECTORY}/pendingPost.json"
          {
            "state": "pending",
            "context": "$(checkContext)",
            "description": "$(checkDescription)",
            "target_url": "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          }
          EOF

          curl -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            -H "${GIT_AUTH}" \
            -X POST \
            '${{ parameters.githubpr.pull_request.statuses_url }}' \
            --data @"${STATUSPOSTOUTPUTDIRECTORY}/pendingPost.json" \
            | tee "${STATUSPOSTOUTPUTDIRECTORY}/pendingReply.json"

          # Error out if the response from GitHub has .errors in it, indicating the
          # API call didn't actually succeed.
          JQ="$(jq -cr '.errors' <"${STATUSPOSTOUTPUTDIRECTORY}/pendingReply.json" >/dev/null)"
          if [ "${JQ}" == 'null' ]; then
            echo '##vso[task.issue type=error;]GitHub pending commit status post failed: ${JQ}'
            echo '##vso[task.complete result=Failed;done=true;]'
          fi
        condition: always()
        displayName: Post pending status to PR commit

      # This script step switches the repository that's been checked out above
      # to the head of the pull request so that we have the code we need to check.
      # NOTE: this only applies in *this job*, so if you split this into multiple
      # jobs each one will need this step.
      - script: |
          git fetch origin pull/${{ parameters.githubpr.number }}/head:pr
          git checkout pr
          git status
        displayName: Switch branch to pull request head

      # Execute all provided checkoutSteps from the inheriting pipeline.
      - ${{ each step in parameters.checkoutSteps }}:
          - ${{ each pair in step }}:
              ${{ pair.key }}: ${{ pair.value }}

      # This sets the overall status variable to success if we get here.
      - script: |
          echo "##vso[task.setvariable variable=pipelineStatus]success"
        displayName: Set pipeline status to success

      # This triggers to set failure state if any previous step failed.
      - script: |
          echo "##vso[task.setvariable variable=pipelineStatus]failure"
        condition: failed()
        displayName: Set pipeline status to failure

      # We always want to run this step, because the fact we got invoked means that
      # GitHub is waiting for us to post back.
      - script: |
          echo "Status post to ${{ parameters.githubpr.pull_request.statuses_url }}:"
          cat << EOF | tee "${STATUSPOSTOUTPUTDIRECTORY}/statusPost.json"
          {
            "state": "$(pipelineStatus)",
            "context": "$(checkContext)",
            "description": "$(checkDescription)",
            "target_url": "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          }
          EOF

          curl -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            -H "${GIT_AUTH}" \
            -X POST \
            '${{ parameters.githubpr.pull_request.statuses_url }}' \
            --data @"${STATUSPOSTOUTPUTDIRECTORY}/statusPost.json" \
            | tee "${STATUSPOSTOUTPUTDIRECTORY}/statusReply.json"

          # Error out if the response from GitHub has .errors in it, indicating the
          # API call didn't actually succeed.
          JQ="$(jq -cr '.errors' <\"${STATUSPOSTOUTPUTDIRECTORY}/statusReply.json\" >/dev/null)"
          if [ "${JQ}" == 'null' ]; then
            echo '##vso[task.issue type=error;]GitHub commit status post failed.'
            echo '##vso[task.complete result=Failed;done=true;]'
          fi
        env:
          GIT_AUTH: $(gitAuthToken)
        condition: always()
        displayName: Post completed status to PR commit

      # Publish what we posted to and received from GitHub into a pipeline artifact
      - task: PublishPipelineArtifact@1
        displayName: Publish status post pipeline artifact
        condition: always()
        inputs:
          targetPath: "$(statusPostOutputDirectory)"
          artifact: "statusPostOutput"
          publishLocation: "pipeline"

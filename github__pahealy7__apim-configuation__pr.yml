# Cross-repository GitHub pull request status check pipeline
# Patrick Healy, patrick.healy@microsoft.com
#
# This pipeline is designed to be triggered using an Azure Pipelines
# Incoming Webhook Service Connection from a GitHub repository based
# on a pull-request webhook. It will only act on actions that indicate
# code was changed, and will run one or more checkout tasks on the pull
# request head branch. It will then use the Azure Pipelines PAT to
# post a commit status back to GitHub, which allows it to be used as a
# protected branch check for pull requests.
#
# NOTE: you must manually trigger this pipeline once to register the
# webhook before GitHub can trigger it.
#
# Azure Pipelines Incoming Webhooks:
# https://docs.microsoft.com/en-us/azure/devops/release-notes/2020/pipelines/sprint-172-update#generic-webhook-based-triggers-for-yaml-pipelines
#
# GitHub commit status post API:
# https://docs.github.com/en/rest/reference/repos#create-a-commit-status
# 
# GitHub pull request webhook event:
# https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads#pull_request

trigger:
  - none

# These are what show in the pull request status check line. The context
# needs to be unique for the repository as it's the identifier used to set
# the required status check.
variables:
  - name: checkContext
    value: Pipeline validation
  - name: checkDescription
    value: AzDO pipeline check
  - name: System.debug
    value: true
  - name: pipelineBuildURL
    value: $(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)

resources:
  # Incoming Webhook service connection
  webhooks:
    - webhook: githubpr
      connection: github__pahealy7__apim-configuration__pr
  # We need a repository resource to the repo we're running the pipeline
  # against, both so that we can get the code and so we can get an access
  # token to post the status back.
  repositories:
    - repository: githubrepo
      type: github
      endpoint: phealy
      name: phealy/apim-configuration

pool:
  vmImage: ubuntu-latest

# Note the condition on this job - it will skip the whole thing unless the
# action is in this list. Because the webhook is triggered for every PR change
# and I don't know how to filter to a list of values in the webhook connection,
# this prevents an agent allocation and finishes the pipeline run successfully
# in <1s when it's just something like a comment on the PR.
jobs:
  - job: performCheckout
    displayName: Perform checkout
    condition: in('${{ parameters.githubpr.action }}', 'opened', 'reopened', 'edited', 'synchronize')
    steps:
      - checkout: githubrepo
        displayName: Check out base repository
        persistCredentials: true
        # persistCredentials allows us to use the PAT generated by AzDO to post
        # to the status API below.

      # Post the initial pending status to GitHub and initialize the tokens for later
      - script: |
          set -eux

          # Create a temporary directory to put our status files in
          STATUSPOSTOUTPUTDIRECTORY="$(mktemp -d)"
          echo "##vso[task.setvariable variable=statusPostOutputDirectory]$STATUSPOSTOUTPUTDIRECTORY"

          # Fetch the PAT from the git configuration.
          GIT_REMOTE="$(git config --get remote.origin.url)"
          GIT_AUTH="$(git config --get "http.${GIT_REMOTE}.extraheader")"
          echo "##vso[task.setvariable variable=gitAuthToken;isSecret=true]$GIT_AUTH"
         
          echo "Status post to ${{ parameters.githubpr.pull_request.statuses_url }}:"
          cat << EOF | tee "${STATUSPOSTOUTPUTDIRECTORY}/pendingPost.json"
          {
            "state": "pending",
            "context": "$(checkContext)",
            "description": "$(checkDescription)",
            "target_url": "$(pipelineBuildURL)"
          }
          EOF

          curl -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            -H "${GIT_AUTH}" \
            -X POST \
            '${{ parameters.githubpr.pull_request.statuses_url }}' \
            --data @"${STATUSPOSTOUTPUTDIRECTORY}/pendingPost.json" \
            | tee "${STATUSPOSTOUTPUTDIRECTORY}/pendingReply.json"

          # Error out if the response from GitHub has .errors in it, indicating the
          # API call didn't actually succeed.
          JQ="$(jq -cr '.errors' <"${STATUSPOSTOUTPUTDIRECTORY}/pendingReply.json" >/dev/null)"
          if [ "${JQ}" == 'null' ]; then
            echo '##vso[task.issue type=error;]GitHub pending commit status post failed: ${JQ}'
            echo '##vso[task.complete result=Failed;done=true;]'
          fi
        condition: always()
        displayName: Post pending status to PR commit

      # This script step switches the repository that's been checked out above
      # to the head of the pull request so that we have the code we need to check.
      # NOTE: this only applies in *this job*, so if you split this into multiple
      # jobs each one will need this step.
      - script: |
          set -eux
          git fetch origin pull/${{ parameters.githubpr.number }}/head:pr
          git checkout pr
          git status
        displayName: Switch branch to pull request head

      # Implement checkout tasks here - any failing step will cause the pipeline
      # to terminate and post a failure to the commit.
      - script: |
          set -eux
          # IMPLEMENT YOUR CHECKOUT TASK(S) HERE
          sleep 5
          # This example will fail in step 1 if the file "fail1" exists
          test -f fail1 && {
            echo '##vso[task.issue type=error;]Failed in checkout step 1.'
            echo '##vso[task.complete result=Failed;done=true;]'
          } || { true; }
        displayName: Perform checkout step 1

      - script: |
          set -eux
          # ANOTHER CHECKOUT TASK
          sleep 5
          # This example will fail in step 1 if the file "fail2" exists
          test -f fail2 && {
            echo '##vso[task.issue type=error;]Failed in checkout step 2.'
            echo '##vso[task.complete result=Failed;done=true;]'
          } || { true; }
        displayName: Perform checkout step 2

      # This sets the overall status variable to success if we get here.
      - script: |
          set -eux
          echo "##vso[task.setvariable variable=pipelineStatus]success"
        displayName: Set pipeline status to success

      # This triggers to set failure state if any previous step failed.
      - script: |
          set -eux
          echo "##vso[task.setvariable variable=pipelineStatus]failure"
        condition: failed()
        displayName: Set pipeline status to failure

      # We always want to run this step, because the fact we got invoked means that
      # GitHub is waiting for us to post back.
      - script: |
          set -eux

          echo "Status post to ${{ parameters.githubpr.pull_request.statuses_url }}:"
          cat << EOF | tee "${STATUSPOSTOUTPUTDIRECTORY}/statusPost.json"
          {
            "state": "$(pipelineStatus)",
            "context": "$(checkContext)",
            "description": "$(checkDescription)",
            "target_url": "$(pipelineBuildURL)"
          }
          EOF

          curl -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            -H "${GIT_AUTH}" \
            -X POST \
            '${{ parameters.githubpr.pull_request.statuses_url }}' \
            --data @"${STATUSPOSTOUTPUTDIRECTORY}/statusPost.json" \
            | tee "${STATUSPOSTOUTPUTDIRECTORY}/statusReply.json"

          # Error out if the response from GitHub has .errors in it, indicating the
          # API call didn't actually succeed.
          JQ="$(jq -cr '.errors' <\"${STATUSPOSTOUTPUTDIRECTORY}/statusReply.json\" >/dev/null)"
          if [ "${JQ}" == 'null' ]; then
            echo '##vso[task.issue type=error;]GitHub commit status post failed.'
            echo '##vso[task.complete result=Failed;done=true;]'
          fi
        env:
          GIT_AUTH: $(gitAuthToken)
        condition: always()
        displayName: Post completed status to PR commit

      # Publish what we posted to and received from GitHub into a pipeline artifact
      - task: PublishPipelineArtifact@1
        displayName: Publish status post pipeline artifact
        condition: always()
        inputs:
          targetPath: '$(statusPostOutputDirectory)'
          artifact: 'statusPostOutput'
          publishLocation: 'pipeline'
# Cross-repository GitHub pull request status check pipeline
# Patrick Healy, patrick.healy@microsoft.com
#
# This pipeline is designed to be triggered using an Azure Pipelines
# Incoming Webhook Service Connection from a GitHub repository based
# on a pull-request webhook. It will only act on actions that indicate
# code was changed, and will run one or more checkout tasks on the pull
# request head branch. It will then use the Azure Pipelines PAT to
# post a commit status back to GitHub, which allows it to be used as a
# protected branch check for pull requests.
#
# NOTE: you must manually trigger this pipeline once to register the
# webhook before GitHub can trigger it.
#
# Azure Pipelines Incoming Webhooks:
# https://docs.microsoft.com/en-us/azure/devops/release-notes/2020/pipelines/sprint-172-update#generic-webhook-based-triggers-for-yaml-pipelines
#
# GitHub commit status post API:
# https://docs.github.com/en/rest/reference/repos#create-a-commit-status
#
# GitHub pull request webhook event:
# https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads#pull_request

trigger:
  - none

pr:
  - none

variables:
  # These are what show in the pull request status check line. The context
  # needs to be unique for the repository as it's the identifier used to set
  # the required status check.
  checkContext: Pipeline validation
  checkDescription: AzDO pipeline check

resources:
  # Incoming Webhook service connection
  webhooks:
    - webhook: githubpr
      connection: apim-configuration
  # We need a repository resource to the repo we're running the pipeline
  # against, both so that we can get the code and so we can get an access
  # token to post the status back.
  repositories:
    - repository: githubrepo
      type: github
      endpoint: phealy
      name: phealy/apim-configuration

pool:
  vmImage: ubuntu-latest

# Note the condition on this job - it will skip the whole thing unless the
# action is in this list. Because the webhook is triggered for every PR change
# and I don't know how to filter to a list of values in the webhook connection,
# this prevents an agent allocation and finishes the pipeline run successfully
# in <1s when it's just something like a comment on the PR.
jobs:
  - job: setupCheckout
    displayName: Setup for checkout
    condition: in('${{ parameters.githubpr.action }}', 'opened', 'reopened', 'edited', 'synchronize')
    steps:
      # Performing this checkout with persistCredentials allows us to use 
      # the authentication token generated by AzDO to post to the status
      # API below.
      - checkout: githubrepo
        displayName: Check out base repository
        persistCredentials: true

      # Set up some initial variables
      - script: |
          set -euo pipefail

          echo "Pull Request URL: ${{ parameters.githubpr.pull_request.url }}"
          echo "##vso[build.updatebuildnumber]WEBHOOK_${{ parameters.githubpr.pull_request.head.repo.name }}_pullrequest_${{ parameters.githubpr.number }}"

          # Create a temporary directory to put our status files in
          echo "##vso[task.setvariable variable=statusPostOutputDirectory]$(mktemp -d)"

          # Fetch the PAT from the git configuration.
          GIT_REMOTE="$(git config --get remote.origin.url)"
          GIT_AUTH="$(git config --get "http.${GIT_REMOTE}.extraheader")"
          echo "GIT_AUTH is $GIT_AUTH"
          echo "##vso[task.setvariable variable=gitAuthToken;isOutput=true;isSecret=true]${GIT_AUTH##Authorization: }"
        displayName: Set pipeline variables

      # Post the initial pending status to GitHub
      - script: |
          set -euo pipefail
          echo "##[command]Status post to ${{ parameters.githubpr.pull_request.statuses_url }}"
          echo "##[group]Post body"
          cat << EOF | tee "$(Build.StagingDirectory)/pendingPost.json"
          {
            "state": "pending",
            "context": "$(checkContext)",
            "description": "$(checkDescription)",
            "target_url": "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          }
          EOF
          echo "##[endgroup]"
          echo "GIT_AUTH is $GIT_AUTH"
          echo "##[group]curl output"
          set -x
          curl --no-progress-meter --fail \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: ${GIT_AUTH}" \
            -H "Content-Type: application/json" \
            -X POST \
            '${{ parameters.githubpr.pull_request.statuses_url }}' \
            --data @"$(Build.StagingDirectory)/pendingPost.json" \
            | tee "$(Build.StagingDirectory)/pendingReply.json"
          set +x
          echo "##[endgroup]"

          # Error out if the response from GitHub has .errors in it, indicating the
          # API call didn't actually succeed.
          JQERRORS="$(jq -cr '.errors != null or .message == "Not Found"' <$(Build.StagingDirectory)/pendingReply.json)"
          if [ "${JQERRORS}" == 'true' ]; then
            echo '##vso[task.issue type=error;]GitHub pending commit status post failed: ${JQ}'
            echo '##vso[task.complete result=Failed;done=true;]'
          fi
        env:
          GIT_AUTH: $(gitAuthToken)
        condition: always()
        displayName: Post pending status to PR commit

  - job: performCheckout
    displayName: Perform checkout
    dependsOn: setupCheckout
    steps:
      # This script step switches the repository that's been checked out above
      # to the head of the pull request so that we have the code we need to check.
      # NOTE: this only applies in *this job*, so if you split this into multiple
      # jobs each one will need this step.
      - checkout: githubrepo
        displayName: Check out base repository
        persistCredentials: true
      - script: |
          set -euo pipefail
          echo "##[command]Fetch pull request head as branch 'pr'"
          git fetch origin pull/${{ parameters.githubpr.number }}/head:pr
          echo "##[command]Check out 'pr' branch"
          git checkout pr
        displayName: Switch branch to pull request head

      ### CHECKOUT STEPS START HERE
      - script: |
          # IMPLEMENT YOUR CHECKOUT TASK(S) HERE
          sleep 5
          # This example will fail in step 1 if the file "fail1" exists
          test -f fail1 && {
            echo '##vso[task.issue type=error;]Failed in checkout step 1.'
            echo '##vso[task.complete result=Failed;done=true;]'
          } || { true; }
        displayName: Perform checkout step 1

      - script: |
          # ANOTHER CHECKOUT TASK
          sleep 5
          # This example will fail in step 1 if the file "fail2" exists
          test -f fail2 && {
            echo '##vso[task.issue type=error;]Failed in checkout step 2.'
            echo '##vso[task.complete result=Failed;done=true;]'
          } || { true; }
        displayName: Perform checkout step 2
      ### CHECKOUT STEPS END HERE

  # We always want to run this job if the checkout ran, because the fact 
  # we got invoked means that GitHub is waiting for us to post back.
  - job: finalizeCheckout
    displayName: Finalize checkout
    dependsOn: performCheckout
    condition: succeededOrFailed()
    steps:
      - script: |
          set -euo pipefail
          
          echo "##[command]Found checkout status: $[dependencies.performCheckout.result]"
          case "$[dependencies.performCheckout.result]" in
            Succeeded) STATUS="success";;
            Failed|Cancelled) STATUS="failure";;
            *) STATUS="failure";;
          esac

          echo "##[command]Status post to ${{ parameters.githubpr.pull_request.statuses_url }}"
          echo "##[group]Post body"
          cat << EOF | tee "$(Build.StagingDirectory)/statusPost.json"
          {
            "state": "$(pipelineStatus)",
            "context": "$(checkContext)",
            "description": "$(checkDescription)",
            "target_url": "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          }
          EOF
          echo "##[endgroup]"

          echo "##[group]curl output"
          curl --no-progress-meter \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: ${GIT_AUTH}" \
            -H "Content-Type: application/json" \
            -X POST \
            '${{ parameters.githubpr.pull_request.statuses_url }}' \
            --data @"$(Build.StagingDirectory)/statusPost.json" \
            | tee "$(Build.StagingDirectory)/statusReply.json"
          echo "##[endgroup]"

          # Error out if the response from GitHub has .errors in it, indicating the
          # API call didn't actually succeed.
          JQERRORS="$(jq -cr '.errors != null or .message == "Not Found"' <$(Build.StagingDirectory)/statusReply.json)"
          if [ "${JQERRORS}" == 'true' ]; then
            echo '##vso[task.issue type=error;]GitHub commit status post failed.'
            echo '##vso[task.complete result=Failed;done=true;]'
          fi
        env:
          GIT_AUTH: $[dependencies.setupCheckout.gitAuthToken]
        condition: always()
        displayName: Post completed status to PR commit

      # Publish what we posted to and received from GitHub into a pipeline artifact
      - task: PublishPipelineArtifact@1
        displayName: Publish status post pipeline artifact
        condition: always()
        inputs:
          artifact: "statusPostOutput"
          publishLocation: "pipeline"
